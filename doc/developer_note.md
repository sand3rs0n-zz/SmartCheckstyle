# Developer Document

## Build & Run

1. By default, developer can build project with gradle. The script, ```./gradlew``` should download and install all dependencies required, and below command will generate a build in ```build/libs/```folder.
   
   ```bash
    ./gradlew build
    gradle genJar
   ```

2. Developer can verify the build with below command. 
   ```bash
    java -jar build/libs/SmartCheckstyle-all-1.0-SNAPSHOT.jar -h
   ```

3. Checkers/modifiers get triggered based on the arguements, and they will print out the errors sorted by package, file name, and line number.

## New Features

Developer can extend existing capabilities and also add new checker or modifiers.

### Adding new checker/modifier.

1. Create a new checker class in ```src/main/java/checkers (or modifiers)``` folder.
   ```java
    public class MyNewChecker extends VoidVisitorAdapter<List<Issue>> {

    private String packageName;
    private String fileName;
    private final static String ISSUE_TYPE = "MY_NEW_CHECK_TYPE";
    
    public MyNewChecker(String fileName) {
        this.fileName = fileName;
    }
   ```

2. Implemente the method for the node in business.
   
   ```java
    @Override
    public void visit(FieldDeclaration n, List<Issue> issues) {
        super.visit(n, issues);
        if (n.isPublic()) {
            if (!n.hasJavaDocComment()) {
                int lineNumber = n.getRange().get().begin.line;
                String fieldName = n.getMetaModel().getMetaModelFieldName();
                issues.add(generateIssue(lineNumber, "Public field "
                        + fieldName + " is missing document."));
            }
        }
    }
   ```

### Integration to main interface

Developer also need to integrate the new checker/modifier in main function with a unique argument.

## Test

### Debugging and testing checker/modifier

1. Manual testing
   For the purpose of studying javaparser APIs and quick testing, sample java files can be created and the javaparser library will create an instance of ComplilationUnit object. And checker/modifier can take the object to do their job. But once the impelentation needs more test against more large set of data, it's good to integrate with ```Main.java``` and run smoke test by passing input directory,  ```-i <path>```. 

2. Using JUnit frameworks
   It's also useful to use JUnit framework to test new checker/modifier. In unittest, developer can write the code that constructs abstract syntax tree(AST) from empty with a certain issue and test with a new checker/modifier. And he/she also get AST from a sample file and modify(i.e., chop javadoc) to miss some style. Below code show the case. The AST, CompliationUnit, gets generated by parsing existing file. The ```JavadocRemover``` modifer removes all recommended javadocs.

   ```java
    public class JavadocRemover extends ModifierVisitor {

        //...
        
        @Override
        public Visitable visit(MethodDeclaration n, Object arg) {
            super.visit(n, arg);
            if (!n.isPrivate()) {
                removeJavadoc(n);
            }
            return n;
        
        //...
    }
   ```

    ```java
    public class JavadocCheckerTest{
    
        @Test
        public void testNoJavaDocInPublicClass() throws FileNotFoundException {
            
            ClassLoader classLoader = this.getClass().getClassLoader();
            String fileName = classLoader.getResource("checkers/DocumentChecker1.java").getFile();
            CompilationUnit cu = JavaParser.parse(new File(fileName));
            JavadocRemover jdr = new JavadocRemover();
            jdr.visit(cu, null);
            //...
    
    ```

3. Next level of automated testing - **with style mutation frameworks**.
   For *future and production*, it would be also possible to automate tests by pre-processing input files. For example, starting with top-quality open source projects, we can develop the tool that produces many style-based mutation dataset, i.e., unused import or variables. Then, it will be much easier to test new checkers and modifiers by inspecting the errors found. 

### Build test

Developer can runs all (unit) tests found from the src/test/java directory by using the following command at command prompt.

```bash 
./gradlew clean test
```

With continuous integration environment, the test webpage will be accessible:

![](test_summary.png)
